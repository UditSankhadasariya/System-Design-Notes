==> Fan out - In message-oriented middleware solutions, fan-out is a messaging pattern used to model an information exchange that implies the delivery (or spreading) of a message to one or multiple destinations possibly in parallel, and not halting the process that executes the messaging to wait for any response to that message.[1][2][3]
Fan-out is a messaging pattern where messages are broadcast in a one-to-many arrangement. A basic example of this pattern can be seen in the functionality of a Publish/Subscribe messaging system, as Pub/Sub implies the ability to route messages from a single sender to multiple receivers.

A more complex fan-out messaging pattern based on Pub/Sub might be used by a publisher to push messages to all or some of its channels so that various subscribers in separate channels can receive the same message at the same time. This can be useful when a method of across-the-board notification for a related set of subscribers is needed.


------------------------------------------------------------------------------------------------------------------------

==> reverse proxy - there tow thing forward proxy which sits in front of the client to impose borwising restrictions, block access to content or to protect identity online(vpn). On the other hand, reverse proxy is the one sits in fornt of the webservers instead of the client.
A simplified way to sum it up would be to say that a forward proxy sits in front of a client and ensures that no origin server ever communicates directly with that specific client. On the other hand, a reverse proxy sits in front of an origin server and ensures that no client ever communicates directly with that origin server.
con- reverse proxy can become a bottle neck for the system as it is the only point of contact.
Benefits of reverse proxy:-
    - Load balancing
    - protection from attacks(DDos) as they dont have acces to the origin server
    -  Global Server Load Balancing (GSLB) - In this form of load balancing, a website can be distributed on several servers around the globe and the reverse proxy will send clients to the server thatâ€™s geographically closest to them. This decreases the distances that requests and responses need to travel, minimizing load times.
    - caching
    - SSL encryption - Encrypting and decrypting SSL (or TLS) communications for each client can be computationally expensive for an origin server. A reverse proxy can be configured to decrypt all incoming requests and encrypt all outgoing responses, freeing up valuable resources on the origin server.


------------------------------------------------------------------------------------------------------------------------

==> Map reduce - performs processing of large data in distributed and parallel manner.(Divide conquer)
        We have a map state weherin we divide the data in data nodes, process it conucrrently(if same business logic is to be applied on all the data) and bthan reduce it(aggregate it) to get the final desired result.
        Eg would to get the word count in sentence, so we will divide it count all words and aggergate the result.

==> Spark - in-memoery fast ditributed processing. It contains RDD(Resilient Distributed datasets), whcih saves time taken in readinga ndwirting, hence it is 10x faster than haddoop. everything is in-memory(RAM). they are called resilient bcz they are designed to handle failure of any worker node in teh cluster. And it ensures that loss of data is zero(just like kuberntes cluster).


MapReduce is a programming model and an associated implementation for processing and generating large data sets, with a parallel, distributed algorithm on a cluster. It was introduced by Google in a white paper in 2004, and it is now widely used in big data processing, particularly in the Hadoop ecosystem.

MapReduce is designed to process large data sets by dividing the work into two distinct phases:

Map: The map phase applies a user-specified function (the "map function") to each input data item and generates a set of intermediate key-value pairs. The function takes an input pair (key, value) and produces a set of intermediate key-value pairs.

Reduce: The reduce phase takes the intermediate key-value pairs generated by the map function and applies another user-specified function (the "reduce function") to them. The reduce function takes an intermediate key and a set of intermediate values, and it combines these values into a smaller set of output values.

The key-value pairs generated by the map function are then sorted by key and passed to the reduce function. This allows the reduce function to process all values for a particular key together, which is useful for tasks such as counting, summing, or averaging the values


------------------------------------------------------------------------------------------------------------------------

